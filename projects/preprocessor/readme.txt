<% point_start('history');%>
История изменений проекта PREPROCESSOR

+ добавлен тег import для импортирования файлов из других проектов
~ исправлен глюк с летним-зимним временем в нативной touch функции, которая 
приводила к установке времени на час назад 
thanks contacto at lucasfonzalida.com.ar and php.net ;)
0.9
+ добавлен тег echo - просто обработать содержимое. без указания имени файла. 
  при указании параметра NAME - будет создан файл с таким именем.
+ Для возможности переименовать файл при обработке, добавлен параметр NAME в тег file. 
~ исправлен механизм обработки ошибок парсинга.  
0.8 (beta)
первый публичный релиз
<% point_start('cookbook'); %>
тут будут советы по приготовлению проектов на парУ

- мой редактор не любит ASP-like теги и говорит, что это ошибки
-- Постарайтесь уговорить редактор. Если он уговорам не подлежит, можно использовать вставки кода
препроцессора в комментариях
  // insert_point('mypoint');
или даже так, если код вставляестя в CSS, в котором нет строчного комментария.
  /*  insert_point('mypoint'); */  
после вставки будут добавлены нужные отрывающие-закрывающие скобки комментария.
  
<% point_start('hat');
// шапка для вставки в файлы проекта
%>
----------------------------------------------------------------------------
$Id: PHP Preprocessor, written by Ksnk (sergekoriakin@gmail.com)
Ver : 1.0(beta), Rev: <%=$SVN_Revision%>, Modified: <%=$SVN_Date%>$
----------------------------------------------------------------------------
License GNU/LGPL - Serge Koriakin - Jule 2010
----------------------------------------------------------------------------
<% point_start('readme');
// readme в wiki-разметке. wiki пока усеченный. только параграфы, 
// заголовки и участки кода
%>
==Условная компиляция в PHP. Фантастику в жизнь

===Введение или зачем оно нужно

Казалось бы, зачем благородному дону условная компиляция в php? 

Однако, при создании web-проектов зачастую не хватает этапа "компиляции" скриптов
проекта. К примеру, в шапки всех текстов, выкладываемых на целевой сервер
неплохо бы вставить информацию о проекте, ревизии SVN и какую-нибудь
сопроводительную муть. При создании ajax-based приложения возникает
настойчивое желание спрятать в javascript-строку формочки и стили, созданные в
обычном html редакторе.

При рисовании какой-нибудь заковыристой формочки, основанной на картинке,
размеры этой картинки "гармонично" вливаются в javascript, css и разметку.
Отсутствие констант в CSS служит источником вдохновения для создателей SASS...

Для демонстрации работы заказчику, часто требуется размещать проект на разных серверах с разным окружением. В итоге код проекта 
приходится слегка модифицировать для того или иного сервера,
той или иной среды. 

Изредка посещают крамольные мысли – сделать код
одновременно для php4 и для php5 и под грядущий php6.

Как правило, для таких целей используются файлы
конфигурации, в которые, с соблюдением определенной ловкости рук, упакованы
все кардинальные отличия проекта, в зависимости от погодных условий.

Однако решение некоторых из этих проблем уже есть. :) Нужно просто ввести дополнительный
язык препроцессора и его выполнить...

=== как оно работает?

Веб программист - специалист по PHP
и достаточно логично, что язык препроцессора будет тем-же PHP. Тем более, что
PHP и есть, с какой-то точки зрения, достаточно универсальный язык
препроцесоора. При этом совершенно бесплатно препроцессор приобретает всю могутость
PHP, которой так не хватает другим языкам препроцессинга.
Вот только теги препроцессора должны отличатся от тегов PHP,
чтобы не возникало недоразумений. Пусть они будут asp-like </% %/>. Чтобы
"выполнить" такой текст - достаточно заменить все PHP теги на что-то другое,
поменять asp-like на php теги и исполнить их обычным eval'ом. После этого -
вернуть php теги взад. It's easy... Хотя, чтобы сделать эту простую идею еще и 
полезной - нужно ее усложнить и понять, что же обычно требуется для сборки проекта.

Чтобы не путать с функциями обычного PHP, будем называть функции и константы, 
описанные в тегах препроцессора макрами или макрокомандами. В принципе, они 
именно этим и являются... 

Часто приходится собирать несколько "целей" - комплектов файлов для разных условий 
содержания. Для отладки на локальном сервере, для отладки на целевом сервере, для 
выкладывания конечному клиенту. Так что наш проект - это комплект файлов, которые 
берутся из разных мест с
девелоперской машины и помещаются в определенные каталоги "билда". Различать варианты сборок будем по имени "цели", которую будем хранить в макре $target.  

Чтобы можно было спокойно пользоваться
макрами определенными в других файлах проекта, нужно исполнять их все в одном
цикле. Тогда не нужно будет особенно заботится о видимости
макрокоманд. Зато сам этап исполнения разбивается на 3 этапа - подготовка текста файла 
проекта к исполнению, путем замены тегов, собственно исполнение и возврат тегов обратно.
Так что сначала нам придется каким-то образом описать весь комплект файлов проекта, а 
потом уже пробежаться по этому списку.

Сам препроцессор будет набором скриптов на php и будет запускаться в CLI
режиме. Достаточно несложно включить такой вариант использования в ant-сборщик
для Eclips'а или в какой-нибудь другой билдер. При запуске скрипта мы передадим ему
параметры
  /usr/local/php5/php.exe -f /preprocessor/preprocessor.php /Dtarget=release /Ddst=build/$target config.xml
параметр /D - описание переменных c именами target и dst соответственно. Потом
эти переменные можно будет использовать.

Все переменные окружения доступны в скрипте с префиксом env_.

  set common=/project

переменная будет досупна с именем $env_common

В результате выполнения, появится комплект файлов, модифицированный для того
или иного варианта сборки. Время модификации файлов будет скопировано (touch)
из времени модификации исходных файлов. Для файлов, описанных в секции copy
или file, которые не содержат тегов препроцессора, время будет браться из
исходного файла. Для файлов, собранных препроцессором - время будет
максимальным из времен всех "исходных" файлов, включая config.xml.

если "время" исходных файлов осталось не больше, чем время готового файла -
собственно копирования и обработки файла не производится, что существенно
ускоряет работу с большими объемами файлов проекта.

диагностика ошибок выполнения eval'уируемого кода проверена на php 5.2.8.8 Мне
она представляется странной, однако, вроде работает ;)

===описание файла конфигурации

Для того, чтобы сообщить препроцессору какие файлы входят в проект - создадим
xml файл (config.xml). Вот такого, примерно, вида
	<?xml version="1.0" encoding="UTF-8"?>
	<config>
	    <var name="license"><![CDATA[
	----------------------------------------------------------------------------
	License GNU/LGPL - Serge Koriakin - June 2010
	http://forum.vingrad.ru/users/ksnk
	----------------------------------------------------------------------------
	]]></var>
		<files>
	        <file>rev.tmp</file>
	    </files>
	    <files dir="../cms/plugins">
	        <file>altname.php</file>
	    </files>
	    <files dstdir="$dst">
	        <file>index.php</file>
	        <file name=".htaccess">htaccess.txt</file>
	        <file>project.php</file>
	        <file>*.css</file>
	        <file>.htaccess</file>
	        <copy>style/*.*</copy>
	        <file>engine/hosts.*</file>
	        <file>engine/main.*</file>
	        <file>engine/project_core.*</file>
	        <copy>img/*.*</copy>
	        <file>js/*.*</file>
	        <file>templates/*.*</file>
	    </files>
	    <files dstdir="$dst" dir="../debug/debug">
	        <copy>Debug/HackerConsole/*.*</copy>
	    </files>
	    <files  dstdir="$dst">
	        <copy>uploaded/*.*</copy>
	    </files>
	</config>
Все используемые здесь пути вычисляются относительно расположения самого
config.xml

config - объемлющие скобки этого xml

var - завести строковую переменную с именем name. В текстах проекта этой переменной можно пользоваться
внутри тегов препроцессора. Можно пользоватся параметром default, чтобы определить переменную, которой 
не было присвоено значение ранее.
Областью видимости переменной будет тот блок групповых тегов, в котором она описана

import - параметр NAME тега указыывает на xml файл, файлы из которого будут вставлены в этот список.
При этом имя XLM файла задается относительно текущего XML, а имена файлов в новом XML - относительно его самого
Таким образом можно импортировать файлы из других проектов. 
  
files - объединяет группу файлов с одинаковыми параметрами dir и dstdir, а также служит ограничителем области видимости тегов
var и remove.
  dir - каталог, откуда будут браться файлы, dstdir - куда они будут помещаться.
  name - имя группы файлов. Эту группу можно исключить по имени тегом remove.
  
file - маска файлов, с которыми будет проводится "выполнение" препроцессором.
Каталог перед именем файла означает, что в каталоги билда будет создана
такая-же структура. Кстати, здесь могут быть заданы свои парамеры dir и dstdir,
которые перекрывают параметры "верхнего" уровня. В дополнение может быть задан 
параметр name - имя файла, в который будет копироваться исходный
	<files dstdir="$dst" dir="../debug/debug">
	    <copy>Debug/HackerConsole/*.*</copy>
	</files>
этот кусок, к примеру, означает, что все файлы
  ../debug/debug/Debug/HackerConsole/*.* будут размещены в каталоге
$dst/Debug/HackerConsole
	<file name=".htaccess">htaccess.txt</file>
означает, что файл htaccess.txt будет помещен в нужный каталог под именем .htaccess. 
(одна из причин такого переименования та, что Eclipse не любит показывать файлы с точкой 
вначале имени в списке файлов проекта).	
	        
$dst - переменная, которая задается в командной строке.

copy - все файлы, подходящие под маску будут просто скопированы в каталог
назначения без eval'а с теми же правилами по поводу каталогов.

echo - весь текст внутри тега воспринимается как содержимое файла. Если необходимо записать содержимое 
в файл, нужно ставить параметр NAME.
	<files dstdir="$dst">
	    <echo name="readme.txt"><![CDATA[<%=point('readme','wiki_txt');%>]]></echo>
	</files>
	
remove - выкидывает из сформированного списка файлы по маске. при этом выкидываются файлы по "исходному" имени.
Следует понимать, что "сокращенное" имя при формировании пары "файл - место назначения", заменяется на полное 
имя до исходного файла. Файл, который попадает под маску "выкидывания" не выполняется. В качестве символов для маски используются 
 * - аналог [^:/\\]* - все символы, кроме / :
 ** - .* - вообще все символы 
 ? - [^:/\\.] - один символ внутри имени файла.
  <remove>**/chat/*</remove> - будут выкинуты все имена, находящиеся в каталоге chat. Например
  /project/version/chat/chat.php. но не /project/version/chat.php

  <files name="tdd.debug.email_test">... </files>  
  <files name="debug.chat_debug">... </files>  
  ...
  <remove name="tdd.*"/> - выкинуть из списка файлы, описанные в группе. вместо имени может использоватся маска, которая будет 
  применяться к именам групп файлов.  
  
Если конструкция внутри тега remove начинается и заканчивается символом тильда ~, то оно считается регулярным выражением и 
непосредственно применяется ко всем именам в парах.

область действия remove ограничена тегом files, в котором он описан. Если тег встречается вне тега files, функция 
применяется ко всему уже сформированному списку файлов. Список файлов заполняется последовательно, по мере чтения файла
конфигурации, так что после remove можно опять вставлять файлы   
  
===Макро ООП.

Отвлечемся теперь от всей этой мути и представим себе работающий web-проект.
Вообразим себе, что начальнику проекта приспичило вставить в проект фенечку,
использующую диалоговое окошко, описанное в некоем плагине. Этот плагин
предполагает, что будут добавлены некие стили в файл стилей, добавлена некая
разметка в html файл, добавлены некие файлы в каталог проекта и изменен один
или несколько javaScript файлов проекта. Если наша фенечка использует ajax,
при этом возникнет желание поменять и php-файлы. Изменения каждый раз
невелики, однако они размазаны по большому количеству файлов, уследить за ними
даже с использованием системы контроля версий может быть непросто. Особенно
страшно становится, когда начальник в творческих муках перебирает многие
варианты таких фенечек от разных производителей.

Как наш новоявленный компилятор может облегчить нашу судьбу в этом случае?
Легко!

Мысленно представим себе куда и как мы будем вставлять компоненты фенечки. В
функцию, вызывающуюся в методе onload документа будет вставлен код
инициализации фенечки. Вставим туда код

  </% insert_point ('js_onload'); %/>

В том-же файле нам нужно описать поведение фенечки. Все это мы запихаем в
область файла, в которой описываются все такие функции общего назначения

  //</% insert_point ('js_body'); %/>

В css файл мы будем добавлять некие стили. Туда запихаем:

  </% insert_point ('css_styles'); %/>

В html шаблон окна приложения нужно вставить заготовку диалогового окна. Туда
поместим

  </% insert_point ('html_body'); %/>

Вот, вроде и все, если про ajax пока забыть…

А теперь, со всем этим хозяйством начнем взлетать. Соединим все конструктивные
части фенечки в одном файле, однако разделим эти конструктивные части
конструкциями point_start и point_finish.

  <html>
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>fenechka module</title>
  <script type=”text/javascript”>
	  </% point_start('js_body'); %/>
	  function Fenechka(){
	
	  }
	  </% point_start('js_onload'); %/>
	  Fenechka();
	  </% point_finish(); %/>
  </script>

  <style type=”text/css”>
	  </% point_start('css_style'); %/>
	  #fenechka { visible:none;}
	  </% point_finish(); %/>
  </style>
  </head>

  <body>
  </% point_start('html_body'); %/>

  <div id="fenechka">Hello world!</div>
	  </% point_finish(); %/>
  </div>

  </body>
  </html>

При некоторой ловкости рук, файл с модулем может одновременно оказаться
простой тестовой площадкой для проверки фенечки в отдельном окне. Впрочем, не
в этом счастье.

Добавим строчку <file>fenechka.html</file> в первый блок (без сохранения
результатов) нашего файла конфигурации, откомпилируем проект и
незамедлительно, после исправления совсем уж явных опечаток, случится чудо!
Все необходимые части нашего нового функционала вставятся в правильные места
нашего проекта. Если по какой-то причине использование фенечки не понравится
заказчикам, чтобы убрать ее из проекта, достаточно выкинуть одну строку
конфигурации.

Реализация механизма находится в файле point.ext.php исходника.

===Исходные файлы препроцессора.

Препроцессор поставляется с «исходным текстом», находящимся в каталоге src и является результатом выполнения этого текста
В результирующий файлы вставляются шапки с номером версии и описанием.
Файл readme.txt форматируется в соответствии с упрощенным wiki.

Для создания препроцессора использовался Eclipse с Ant’ом и система с установленным TortuiseSVN, что накладывает отпечаток на используемые инструменты.

src/Build.xlm – make-файл для Ant’а. Он описывает пару макрокоманд – preprocessor – собственно вызов препроцессора и SVNcheck – вызов утилиты SubWCRev для внедрения номера ревизии SVN в текст.

src/Config.xml – файл конфигурации препроцессора, список файлов проекта 

preprocessor.php - главный файл, анализ командной строки и вызов препроцессора

preprocessor.class.php - класс с методами препроцессора - сборка и хранение
пар Source-Destination, исполнение файла препроцессором, собственно чтение и
анализ файла конфигурации.

point.ext.php - набор функций, для реализации MACRO-OOP.

wiki.ext.php - класс для работы с wiki-разметкой. разметка пока сильно упрощенная.

<% point_finish() ;
echo point('readme','wiki-txt')%>
